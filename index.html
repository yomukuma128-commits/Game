<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>チェッカー（連続ジャンプ対応・高視認性）</title>
<style>
body{
  font-family:sans-serif;
  text-align:center;
  background:#eef2f7;
}
#board{
  display:grid;
  grid-template-columns:repeat(8,68px);
  width:544px;
  margin:20px auto;
  border:6px solid #2f3e55;
}
.square{
  width:68px;height:68px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.dark{background:#3b4f7a;}
.light{background:#f7f9fc;}

.piece{
  width:50px;height:50px;
  border-radius:50%;
  cursor:pointer;
  position:relative;
}
.white{background:#fbfdff;border:2px solid #9aa4b2;}
.blackp{background:#1f2a44;}

.king::after{
  content:"";
  position:absolute;
  inset:8px;
  border:5px solid #f2c94c;
  border-radius:50%;
}

.selected{
  outline:5px solid #4fd1c5;
}
</style>
</head>
<body>

<h1>チェッカー（公式ルール完成形）</h1>

<select id="mode">
  <option value="pvp">対人戦</option>
  <option value="cpu">コンピュータ戦</option>
</select>

<select id="level">
  <option value="1">AI Lv1</option>
  <option value="2">AI Lv2</option>
  <option value="3">AI Lv3</option>
</select>

<button onclick="resetGame()">リセット</button>
<p id="status"></p>

<div id="board"></div>

<script>
const board=document.getElementById("board");
const status=document.getElementById("status");

let state,current,selected,chain=false;

function resetGame(){
  current="white";
  selected=null;
  chain=false;
  state=Array(8).fill().map(()=>Array(8).fill(null));
  for(let y=0;y<3;y++)for(let x=0;x<8;x++)
    if((x+y)%2)state[y][x]={c:"black",k:false};
  for(let y=5;y<8;y++)for(let x=0;x<8;x++)
    if((x+y)%2)state[y][x]={c:"white",k:false};
  draw();
}

function draw(){
  board.innerHTML="";
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const sq=document.createElement("div");
    sq.className="square "+((x+y)%2?"dark":"light");
    sq.onclick=()=>click(x,y);
    const p=state[y][x];
    if(p){
      const d=document.createElement("div");
      d.className="piece "+(p.c==="white"?"white":"blackp");
      if(p.k)d.classList.add("king");
      if(selected && selected.x===x && selected.y===y)
        d.classList.add("selected");
      sq.appendChild(d);
    }
    board.appendChild(sq);
  }
  status.textContent=
    chain ? `${current}：連続ジャンプ中`
          : `${current} の番`;
}

function click(x,y){
  if(mode.value==="cpu" && current==="black")return;

  if(selected){
    const r=move(state,selected.x,selected.y,x,y,true);
    if(r==="again"){
      selected={x,y};
      chain=true;
    }else if(r){
      selected=null;
      chain=false;
      turn();
    }else{
      selected=null;
      chain=false;
    }
  }else if(state[y][x]?.c===current){
    if(!chain)selected={x,y};
  }
  draw();
}

function move(b,sx,sy,tx,ty,real){
  const p=b[sy][sx];
  if(!p||b[ty][tx])return false;

  const dx=tx-sx,dy=ty-sy;
  const dirs=p.k?[1,-1]:[p.c==="white"?-1:1];

  for(const d of dirs){
    if(Math.abs(dx)===2 && dy===d*2){
      const mx=sx+dx/2,my=sy+dy/2;
      if(b[my][mx] && b[my][mx].c!==p.c){
        b[ty][tx]=p;b[sy][sx]=null;b[my][mx]=null;
        kingCheck(p,ty);
        if(hasCapture(b,tx,ty,p))
          return "again";
        return true;
      }
    }
  }

  if(chain || hasAnyCapture(current))return false;

  for(const d of dirs){
    if(Math.abs(dx)===1 && dy===d){
      b[ty][tx]=p;b[sy][sx]=null;
      kingCheck(p,ty);
      return true;
    }
  }
  return false;
}

function hasAnyCapture(player){
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=state[y][x];
    if(p?.c===player && hasCapture(state,x,y,p))
      return true;
  }
  return false;
}

function hasCapture(b,x,y,p){
  const dirs=p.k?[1,-1]:[p.c==="white"?-1:1];
  for(const d of dirs){
    for(const dx of [-2,2]){
      const nx=x+dx,ny=y+d*2;
      if(nx>=0&&ny>=0&&nx<8&&ny<8){
        const mx=x+dx/2,my=y+d;
        if(b[my][mx] && b[my][mx].c!==p.c && !b[ny][nx])
          return true;
      }
    }
  }
  return false;
}

function kingCheck(p,y){
  if((p.c==="white"&&y===0)||(p.c==="black"&&y===7))
    p.k=true;
}

function turn(){
  current=current==="white"?"black":"white";
  draw();
  if(mode.value==="cpu" && current==="black")
    setTimeout(cpuMove,500);
}

function cpuMove(){
  let moves=getMoves("black");
  let m=moves[Math.floor(Math.random()*moves.length)];
  state=m.b;
  if(m.chain){
    setTimeout(cpuMove,400);
  }else{
    turn();
  }
}

function getMoves(player){
  let list=[];
  let mustCap=hasAnyCapture(player);
  for(let y=0;y<8;y++)for(let x=0;x<8;x++){
    const p=state[y][x];
    if(p?.c===player){
      const dirs=p.k?[1,-1]:[1];
      for(const d of dirs){
        for(const dx of [-2,2]){
          const nx=x+dx,ny=y+d*2;
          if(nx>=0&&ny>=0&&nx<8&&ny<8){
            const copy=JSON.parse(JSON.stringify(state));
            if(move(copy,x,y,nx,ny,false))
              list.push({b:copy,chain:hasCapture(copy,nx,ny,p)});
          }
        }
      }
      if(!mustCap){
        for(const d of dirs){
          for(const dx of [-1,1]){
            const nx=x+dx,ny=y+d;
            if(nx>=0&&ny>=0&&nx<8&&ny<8){
              const copy=JSON.parse(JSON.stringify(state));
              if(move(copy,x,y,nx,ny,false))
                list.push({b:copy,chain:false});
            }
          }
        }
      }
    }
  }
  return list;
}

resetGame();
</script>
</body>
</html>
